import 'package:path/path.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class DatabaseHelper {
  static Database? _database;
  final String productTableName = 'product_table';
  final String salesTableName = 'sales_table';
  final String purchaseTableName = 'purchase_table';

  Future<Database> get database async {
    if (_database != null) return _database!;

    _database = await initDatabase();
    return _database!;
  }

Future<Database> initDatabase() async {
  sqfliteFfiInit();
  databaseFactory = databaseFactoryFfi;
  String path = await getDatabasesPath();

  return await openDatabase(
    join(path, 'your_database_name.db'),
    version: 1,
     onConfigure: (Database db) {
      // Ensure the database is configured for write operations
      db.execute('PRAGMA synchronous = NORMAL');
    },
    onCreate: (Database db, int version) async {
      await db.execute('''
        CREATE TABLE $productTableName (
          name TEXT PRIMARY KEY
        )
      ''');

      List<String> initialProductNames = [
        "20mm SM", "16mm SM", "12mm SM", "10mm SM", "8mm SM",
        "20mm AS", "16mm AS", "12mm AS", "10mm AS", "8mm AS",
        "6mm TMT", "6mm ring", "5mm", "2mm", "Weight",
        "Garter 4K", "Garter 3K", "Garter 2.5K", "Tee 2.7", "Tee 2.2",
        "AL 50/6", "AL 40/6", "AL 35/6", "AL 35/5", "AL 25/3",
        "Local Wire", "Tata Wire", "Cover block", "Patiya", "Ch 2.2K"
      ];

      for (String productName in initialProductNames) {
        await db.insert(productTableName, {'name': productName});
      }

      // Create sales table with dynamic product columns
    await db.execute('''
      CREATE TABLE $salesTableName (
        serial INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT,
        ${initialProductNames.map((name) => '[${name.replaceAll(' ', '_')}] INTEGER').join(',')}
      )
    ''');   

    // Create purchase table with dynamic product columns
    await db.execute('''
      CREATE TABLE $purchaseTableName (
        serial INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT,
        ${initialProductNames.map((name) => '[${name.replaceAll(' ', '_')}] INTEGER').join(',')}
      )
    ''');
    },
  );
}


Future<int> insertSalesData(Map<String, dynamic> data) async {
  Database db = await database;
  Map<String, dynamic> newData = {};

  data.forEach((key, value) {
    newData[key.replaceAll(' ', '_')] = value;
  });

  return await db.insert(salesTableName, newData);
}

Future<int> insertPurchaseData(Map<String, dynamic> data) async {
  Database db = await database;
  Map<String, dynamic> newData = {};

  data.forEach((key, value) {
    newData[key.replaceAll(' ', '_')] = value;
  });

  return await db.insert(purchaseTableName, newData);
}

  Future<List<Map<String, dynamic>>> getSalesData() async {
      Database db = await database;
      List<Map<String, dynamic>> results = await db.query(salesTableName);
      List<Map<String, dynamic>> mutableResults = results.map((data) {
        return Map<String, dynamic>.from(data);
      }).toList();
      return mutableResults;
  }


  //Future<List<Map<String, dynamic>>> getPurchaseData() async {
  //  Database db = await database;
  //  return await db.query(purchaseTableName);
  //}

  Future<List<Map<String, dynamic>>> getProductData() async {
    Database db = await database;
    return await db.query(productTableName);
  }

Future<void> updateSalesData(int serial, Map<String, dynamic> newData) async {
      Database db = await database;
      await db.update(
        salesTableName,
        newData,
        where: 'serial = ?',
        whereArgs: [serial],
      );
}

Future<void> saveChanges(List<Map<String, dynamic>> updatedSalesData) async {
    Database db = await database;
    for (var data in updatedSalesData) {
      Map<String, dynamic> valuesToUpdate = {};

      // Extract values to update excluding the 'serial' field
      for (var entry in data.entries) {
        if (entry.key != 'serial') {
          String columnName = '[${entry.key}]'; // Enclose all columns within square brackets
          valuesToUpdate[columnName] = entry.value;
        }
      }

      int serial = data['serial']; // Assuming 'serial' is the primary key

      await db.update(
        salesTableName,
        Map<String, dynamic>.from(valuesToUpdate), // Use a mutable copy of the data
        where: 'serial = ?',
        whereArgs: [serial],
      );
    }
}

Future<void> checkAndUpdateEntries() async {
  Database db = await database;

  // Get entries older than 10 days
  DateTime tenDaysAgo = DateTime.now().subtract(Duration(days: 10));
  List<Map<String, dynamic>> oldEntries = await db.query(
    salesTableName,
    where: 'date < ?',
    whereArgs: [tenDaysAgo.toIso8601String()],
  );

  if (oldEntries.isNotEmpty) {
    // Get the most recent date from the database
    List<Map<String, dynamic>> recentEntry = await db.query(
      salesTableName,
      orderBy: 'date DESC',
      limit: 1,
    );

    String mostRecentDateString = recentEntry.first['date']; // Assuming it's in dd-mm-yyyy format
    
    // Parse the most recent date
    List<String> parts = mostRecentDateString.split('-');
    int day = int.parse(parts[0]);
    int month = int.parse(parts[1]);
    int year = int.parse(parts[2]);
    DateTime mostRecentDate = DateTime(year, month, day);
    
    // Update dates of entries older than 10 days
    List<Map<String, dynamic>> updatedEntries = [];
    for (var entry in oldEntries) {
      Map<String, dynamic> clonedEntry = Map.from(entry); // Clone the entry
      String entryDateString = clonedEntry['date']; // Assuming it's in dd-mm-yyyy format
      
      // Parse the entry date
      List<String> entryParts = entryDateString.split('-');
      int entryDay = int.parse(entryParts[0]);
      int entryMonth = int.parse(entryParts[1]);
      int entryYear = int.parse(entryParts[2]);
      DateTime entryDate = DateTime(entryYear, entryMonth, entryDay);
      
      // Check if the entry date is older than 10 days
      if (entryDate.isBefore(tenDaysAgo)) {
        // Format the most recent date in dd-mm-yyyy format
        String formattedRecentDate = '${mostRecentDate.day.toString().padLeft(2, '0')}-${mostRecentDate.month.toString().padLeft(2, '0')}-${mostRecentDate.year}';
        clonedEntry['date'] = formattedRecentDate;
        updatedEntries.add(clonedEntry);
      }
    }
    await saveChanges(updatedEntries); // Save changes to the database
  }
}

  Future<List<Map<String, dynamic>>> getPurchaseData() async {
      Database db = await database;
      List<Map<String, dynamic>> results = await db.query(purchaseTableName);

      List<Map<String, dynamic>> mutableResults = results.map((data) {
        return Map<String, dynamic>.from(data);
      }).toList();

      return mutableResults;
  }

  Future<void> saveChangesToPurchaseData(List<Map<String, dynamic>> updatedPurchaseData) async {
      Database db = await database;
      for (var data in updatedPurchaseData) {
        Map<String, dynamic> valuesToUpdate = {};

        for (var entry in data.entries) {
          if (entry.key != 'serial') {
            String columnName = '[${entry.key}]';
            valuesToUpdate[columnName] = entry.value;
          }
        }

        int serial = data['serial'];

        await db.update(
          purchaseTableName,
          Map<String, dynamic>.from(valuesToUpdate),
          where: 'serial = ?',
          whereArgs: [serial],
        );
      }
  }


Future<bool> aggregateSalesOldData(BuildContext context) async {
  try {
    Database db = await database;
    DateTime tenDaysAgo = DateTime.now().subtract(Duration(days: 10));

    String formattedDate = '${tenDaysAgo.day.toString().padLeft(2, '0')}-${tenDaysAgo.month.toString().padLeft(2, '0')}-${tenDaysAgo.year}';
    print(formattedDate);

    List<Map<String, dynamic>> oldSalesEntries = await db.rawQuery(
      'SELECT * FROM sales_table WHERE date < ?',
      [formattedDate],
    );

    if (oldSalesEntries.length == 1) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('No old entries available for sales.'),
        ),
      );
      return false; // Directly return false if only one entry is available
    }

    DateTime? mostRecentDate;
    if (oldSalesEntries.isNotEmpty) {
      mostRecentDate = oldSalesEntries
          .map((entry) => _parseCustomDateFormat(entry['date'] as String))
          .reduce((value, element) => value.isAfter(element) ? value : element);
    }

    String formattedMostRecentDate = mostRecentDate != null
        ? DateFormat('dd-MM-yyyy').format(mostRecentDate)
        : 'N/A'; // or any default value if mostRecentDate is null

    print('Most Recent Date from Fetched Entries: $formattedMostRecentDate');

    if (oldSalesEntries.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('No old entries available for sales.'),
        ),
      );
      return false; // No old entries available, no further operations
    }

    Map<String, dynamic> combinedSalesEntries = {};

    void combineSalesEntries(List<Map<String, dynamic>> entries) {
      entries.forEach((entry) {
        entry.forEach((key, value) {
          if (key != 'date' && key != 'serial') {
            String formattedKey = '[$key]';
            combinedSalesEntries[formattedKey] =
                (combinedSalesEntries[formattedKey] ?? 0) + (value ?? 0);
          }
        });
      });
    }

    combineSalesEntries(oldSalesEntries);

bool updatesMade = await db.transaction((txn) async {
  // Exclude the row with the minimum id from deletion
  await txn.rawDelete(
    'DELETE FROM sales_table WHERE date < ? AND serial != (SELECT MIN(serial) FROM sales_table WHERE date < ?)',
    [formattedDate, formattedDate],
  );

      String latestDateQuery = '''
        SELECT MAX(date) AS latest_date FROM sales_table
        ''';

      List<Map<String, dynamic>> latestDateResult = await txn.rawQuery(latestDateQuery);
      String? latestDate =
          latestDateResult.isNotEmpty ? latestDateResult.first['latest_date'] : null;

      if (latestDate != null) {
        combinedSalesEntries['date'] = latestDate;
         List<Map<String, dynamic>> existingRow = await txn.rawQuery(
      'SELECT * FROM sales_table ORDER BY serial LIMIT 1',
    );

    if (existingRow.isNotEmpty) {
      combinedSalesEntries['date'] = formattedMostRecentDate;
      // Update the existing row with combinedSalesEntries values
      await txn.update(
        'sales_table',
        combinedSalesEntries,
        where: 'serial = ?',
        whereArgs: [existingRow.first['serial']],
      );
    }
      return true; // Updates were made
      }
      return false; // No updates made (latestDate was null)
    });

    return updatesMade;
  } catch (e) {
    print('Error in aggregateSalesOldData: $e');
    // Handle or log the error as needed
    return false; // Error occurred, no updates made
  }
}

DateTime _parseCustomDateFormat(String dateString) {
  final parts = dateString.split('-');
  final day = int.parse(parts[0]);
  final month = int.parse(parts[1]);
  final year = int.parse(parts[2]);
  return DateTime(year, month, day);
}

Future<bool> aggregatePurchaseOldData(BuildContext context) async {
  try {
    Database db = await database;
    DateTime tenDaysAgo = DateTime.now().subtract(Duration(days: 10));
    print(tenDaysAgo);

    String formattedDate = '${tenDaysAgo.year}-${tenDaysAgo.month.toString().padLeft(2, '0')}-${tenDaysAgo.day.toString().padLeft(2, '0')}';

    List<Map<String, dynamic>> oldPurchaseEntries = await db.rawQuery(
        'SELECT * FROM purchase_table WHERE date < ?',
        [formattedDate]);

    if (oldPurchaseEntries.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('No old entries available for purchase.'),
        ),
      );
      return false; // No old entries available, no further operations
    }

    Map<String, dynamic> combinedPurchaseEntries = {};

    void combinePurchaseEntries(List<Map<String, dynamic>> entries) {
      entries.forEach((entry) {
        entry.forEach((key, value) {
          if (key != 'date' && key != 'serial') {
            String formattedKey = '[$key]';
            combinedPurchaseEntries[formattedKey] =
                (combinedPurchaseEntries[formattedKey] ?? 0) + (value ?? 0);
          }
        });
      });
    }

    combinePurchaseEntries(oldPurchaseEntries);

    bool updatesMade = await db.transaction((txn) async {
      await txn.rawDelete('DELETE FROM purchase_table WHERE date < ?', [formattedDate]);

      String latestDateQuery = '''
        SELECT MAX(date) AS latest_date FROM purchase_table
        ''';

      List<Map<String, dynamic>> latestDateResult = await txn.rawQuery(latestDateQuery);
      String? latestDate =
          latestDateResult.isNotEmpty ? latestDateResult.first['latest_date'] : null;

      if (latestDate != null) {
        combinedPurchaseEntries['date'] = latestDate;

        await txn.insert('purchase_table', combinedPurchaseEntries);
        return true; // Updates were made
      }
      return false; // No updates made (latestDate was null)
    });

    return updatesMade;
  } catch (e) {
    print('Error in aggregatePurchaseOldData: $e');
    // Handle or log the error as needed
    return false; // Error occurred, no updates made
  }
}

Future<void> cloneAndReplaceSalesTable(Database db, String tableName, String productsTableName) async {
  try {
    // Fetch initial product names from the 'products' table
    final List<Map<String, dynamic>> products = await db.query(productsTableName);
    final List<String> initialProductNames = products.map((product) => '${product['name'] as String}').toList();

    final List<Map<String, dynamic>> data = await db.query(tableName);
    final List<String> columnNames = data.isNotEmpty ? data.first.keys.toList() : [];

    // Remove 'serial' column from the list of columns
    columnNames.remove('serial');

    // Create a new table with the desired structure
    final String newTableName = '$tableName\_temp';
    final String createTableQuery = '''
        CREATE TABLE $newTableName (
          serial INTEGER PRIMARY KEY AUTOINCREMENT,
          date TEXT,
          ${initialProductNames.map((name) => '[${name.replaceAll(' ', '_')}] INTEGER').join(',')}
        )
    ''';

    print('Creating new table: $newTableName');
    await db.execute(createTableQuery);

    // Insert data into the new table
for (final Map<String, dynamic> row in data) {
  final List<dynamic> values = [];
  values.add(row['date']); // Inserting 'date' value

  initialProductNames.forEach((productName) {
    final String columnName = '[${productName.replaceAll(' ', '_')}]';
    final dynamic value = row[columnName]; // Get value from existing table
    values.add(value); // Add it to the values list for insertion
    print('Column: $columnName, Value: $value');
  });

      // Generating placeholders for the insertion query
      final placeholders = List.generate(values.length, (_) => '?').join(', ');

      print('Inserting data into $newTableName: $values');

      await db.rawInsert(
        'INSERT INTO $newTableName (date, ${initialProductNames.map((name) => '[${name.replaceAll(' ', '_')}]').join(',')}) VALUES (?, ${List.generate(initialProductNames.length, (_) => '?').join(', ')})',
        values,
      );
    }

    // Drop the original table
    print('Dropping original table: $tableName');
    await db.execute('DROP TABLE $tableName');

    // Rename the new table to match the original table
    print('Renaming new table $newTableName to $tableName');
    await db.execute('ALTER TABLE $newTableName RENAME TO $tableName');

    print('Table cloning and replacement successful!');
  } catch (e) {
    print('Error in cloneAndReplaceSalesTable: $e');
    // Handle or log the error as needed
  }
}



}

